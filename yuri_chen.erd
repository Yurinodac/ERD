// Yuri Chen - ER model implementing the provided business rules for RC Models
// Notation: Chen (conceptual / academic style)
// Source business rules used:
// Customer(Cus_Id, Cus_Name)
// Invoice(Inv_Id, Cus_Id, Shipping_Charge, Date_Ordered, Date_Shipped)
// Line(Line_Id, Inv_Id, Product_Id, Vendor_Id, Quantity, Total_Line_Price)
// Product(Product_Id, Product_Name, Vendor_Id, Category, Minimum_Quantity, Price, Quant_On_Hand)
// Vendor(Vendor_Id, Vendor_Name)
// Order(Order_Id, Vendor_Id, Product_Id, Quantity, Price_Per_Unit, Total_Order_Line)


erdiagram YuriChenModel

notation=crowsfoot

// Entities
entity Customer {
    Cus_Id: INTEGER key
    Cus_Name: VARCHAR(200)
    status: VARCHAR(20)    // values: "potential", "interested", "previous"
}

entity Invoice {
    Inv_Id: INTEGER key
    Cus_Id: INTEGER
    Shipping_Charge: DECIMAL(10,2)
    Date_Ordered: DATE
    Date_Shipped: DATE
}

entity Line {
    Line_Id: INTEGER key
    Inv_Id: INTEGER
    Product_Id: INTEGER
    Vendor_Id: INTEGER
    Quantity: INTEGER
    Total_Line_Price: DECIMAL(12,2)
}

entity Product {
    Product_Id: INTEGER key
    Product_Name: VARCHAR(255)
    Vendor_Id: INTEGER
    Category: VARCHAR(100)
    Minimum_Quantity: INTEGER
    Price: DECIMAL(10,2)
    Quant_On_Hand: INTEGER
}

entity Vendor {
    Vendor_Id: INTEGER key
    Vendor_Name: VARCHAR(200)
}

entity Order {
    Order_Id: INTEGER key
    Vendor_Id: INTEGER
    Product_Id: INTEGER
    Quantity: INTEGER
    Price_Per_Unit: DECIMAL(10,2)
    Total_Order_Line: DECIMAL(12,2)
}

// Relationships (cardinalities reflect the supplied business rules)

// Each customer can generate many Invoices but need not generate an invoice to be recorded as a customer;
// Each Invoice must be generated by one and exactly one Customer.
relationship CustomerInvoice {
    Customer[0..N | "customer"] -> Invoice[1 | "invoice"]
}

// Each Invoice must correspond to at least one Line; Each Line must correspond to one and exactly one Invoice.
relationship InvoiceLine {
    Invoice[1 | "invoice"] -> Line[1..N | "line"]
}

// Each Line corresponds to exactly one Product; Each Product can be in many Lines.
relationship ProductLine {
    Product[1 | "product"] -> Line[0..N | "line"]
}

// Each Product is supplied by exactly one Vendor; Each Vendor may supply many Products.
relationship VendorProduct {
    Vendor[1 | "vendor"] -> Product[0..N | "product"]
}

// Each Order is filled by exactly one Vendor; each Vendor may fill many Orders.
relationship VendorOrder {
    Vendor[1 | "vendor"] -> Order[0..N | "orders"]
}

// Each Order has exactly one Product; each Product can be requested by many Orders.
relationship OrderProduct {
    Order[1 | "order"] -> Product[0..N | "product"]
}

// Additional modeling notes / business rules (documented):
// 1. A Customer is recorded whether potential or previous; tracked in Customer.status attribute.
// 2. Orders are automatically placed when Product.Quant_On_Hand <= Product.Minimum_Quantity. (business process outside logical model; documented here)
// 3. Each Invoice has a Shipping_Charge applied after the invoice is printed (process note).
// 4. RC Model will not charge a customer's card if the selected product is not available in inventory (i.e., if Product.Quant_On_Hand < requested Line.Quantity).
// 5. Line includes Vendor_Id to record the vendor chosen for that line (denormalized for reporting or to capture vendor at time of sale). Vendor_Id on Line must match Product.Vendor_Id (data integrity rule).
// 6. Order entity models purchase orders placed to vendors to replenish inventory; Order.Total_Order_Line = Quantity * Price_Per_Unit.

// End of model
